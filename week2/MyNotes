randomized queue 中，deque 不单单是把选出来的index 弹出，
设置null 应该记录空的位置，这样下次enqueue时可以填入，否则size会变得很大
还会是amortized constant time 吗？

2.
compile 通过
但运行时
/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/bin/java "-javaagent:/Applications/IntelliJ IDEA CE.app/Contents/lib/idea_rt.jar=59176:/Applications/IntelliJ IDEA CE.app/Contents/bin" -Dfile.encoding=UTF-8 -classpath /Users/bill/Desktop/Algo_coursera/queues:/Users/bill/Desktop/Algo_coursera/queues/.lift/algs4.jar RandomizedQueue
Exception in thread "main" java.lang.ClassCastException: java.base/java.lang.Object cannot be cast to java.base/[Ljava.lang.Object;
	at RandomizedQueue.<init>(RandomizedQueue.java:23)
	at RandomizedQueue.main(RandomizedQueue.java:118)

code is
array = (Item[]) new Object();

should be array = (Item[]) new Object[1];


3.

Analyzing memory of Deque
*-----------------------------------------------------------
For tests 1-4, the maximum amount of memory allowed for a Deque
containing n items is 48n + 192.

Running 48 total tests.

Test 1a-1i: total memory usage after inserting n items,
            where n is a power of 2

                 n        bytes
----------------------------------------------------------
=> passed       32         1576
=> passed       64         3112
=> passed      128         6184
=> passed      256        12328
=> passed      512        24616
=> passed     1024        49192
=> passed     2048        98344
=> passed     4096       196648
=> passed     8192       393256
==> 9/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 2a-2i: Total memory usage after inserting n items,
            when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33         1624
=> passed       65         3160
=> passed      129         6232
=> passed      257        12376
=> passed      513        24664
=> passed     1025        49240
=> passed     2049        98392
=> passed     4097       196696
=> passed     8193       393304
==> 9/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 3a-3i: Total memory usage after inserting 2n-1 items, and then
            deleting n-1 items, when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> FAILED       33         3160   (1.8x)
=> FAILED       65         6232   (1.9x)
=> FAILED      129        12376   (1.9x)
=> FAILED      257        24664   (2.0x)
=> FAILED      513        49240   (2.0x)
=> FAILED     1025        98392   (2.0x)
=> FAILED     2049       196696   (2.0x)
=> FAILED     4097       393304   (2.0x)
=> FAILED     8193       786520   (2.0x)
==> 0/9 tests passed

Memory: 96.00 n - 8.00   (R^2 = 1.000)


Test 4a-4e: Total memory usage after inserting n items,
            and then deleting all but one item
            (should not grow with n or be too large of a constant).

                 n        bytes
----------------------------------------------------------
=> FAILED       32         1576   (6.6x)
=> FAILED       64         3112  (13.0x)
=> FAILED      128         6184  (25.8x)
=> FAILED      256        12328  (51.4x)
=> FAILED      512        24616 (102.6x)
=> FAILED     1024        49192 (205.0x)
=> FAILED     2048        98344 (409.8x)
=> FAILED     4096       196648 (819.4x)
=> FAILED     8192       393256 (2e+03x)
==> 0/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 5a-5e: Total memory usage of iterator after inserting n items
            (should not grow with n or be too large of a constant).

                 n        bytes
----------------------------------------------------------
=> passed       32           32
=> passed       64           32
=> passed      128           32
=> passed      256           32
=> passed      512           32
=> passed     1024           32
=> passed     2048           32
=> passed     4096           32
=> passed     8192           32
==> 9/9 tests passed

Memory: 32.00   (R^2 = 1.000)


Test 6a: Insert n strings; delete them one at a time, checking for
         loitering after each deletion. The probabilities of addFirst()
         and addLast() are (p1, p2), respectively. The probabilities of
         removeFirst() and removeLast() are (q1, q2), respectively.
  * 100 random insertions (1.0, 0.0) and 100 random deletions (1.0, 0.0)
    - loitering observed during 99 of 100 deletions
    - maximum number of loitered objects at one time = 99

  * 100 random insertions (1.0, 0.0) and 100 random deletions (0.0, 1.0)
    - loitering observed during 99 of 100 deletions
    - maximum number of loitered objects at one time = 99

  * 100 random insertions (0.0, 1.0) and 100 random deletions (1.0, 0.0)
    - loitering observed during 99 of 100 deletions
    - maximum number of loitered objects at one time = 99

  * 100 random insertions (0.0, 1.0) and 100 random deletions (0.0, 1.0)
    - loitering observed during 99 of 100 deletions
    - maximum number of loitered objects at one time = 99

  * 100 random insertions (0.5, 0.5) and 100 random deletions (0.5, 0.5)
    - loitering observed during 100 of 100 deletions
    - maximum number of loitered objects at one time = 100

==> FAILED

Test 6b: Perform random operations, checking for loitering after
         each operation. The probabilities of addFirst(), addLast(),
         removeFirst(), and removeLast() are (p1, p2, p3, p4),
         respectively.
  * 100 random operations (0.8, 0.0, 0.2, 0.0)
    - loitering detected after operation 3 of 100
    - sequence of operations was:
         deque.addFirst("QOPDYKNFFJ")
         deque.addFirst("VQGYLBGWJM")
         deque.removeFirst()     ==> VQGYLBGWJM
    - loitered object(s):
      VQGYLBGWJM

  * 100 random operations (0.8, 0.0, 0.0, 0.2)
    - loitering detected after operation 6 of 100
    - sequence of operations was:
         deque.addFirst("CKSRFKUATF")
         deque.addFirst("OOAGKRMOSG")
         deque.addFirst("ESFEWWOPVQ")
         deque.addFirst("HCILQEWTEA")
         deque.addFirst("FDOTQHUOPS")
         deque.removeLast()      ==> CKSRFKUATF
    - loitered object(s):
      CKSRFKUATF

  * 100 random operations (0.0, 0.8, 0.2, 0.0)
    - loitering detected after operation 6 of 100
    - sequence of operations was:
         deque.addLast("NEGZJGHWIW")
         deque.addLast("COQWGRRUNH")
         deque.addLast("RGUIZRWAVE")
         deque.addLast("WABJNDFJCI")
         deque.addLast("BUWNZQBVSI")
         deque.removeFirst()     ==> NEGZJGHWIW
    - loitered object(s):
      NEGZJGHWIW

  * 100 random operations (0.0, 0.8, 0.0, 0.2)
    - loitering detected after operation 4 of 100
    - sequence of operations was:
         deque.addLast("MCLAOBMAES")
         deque.addLast("YHDBOSDWVV")
         deque.addLast("IVVRFDSOLE")
         deque.removeLast()      ==> IVVRFDSOLE
    - loitered object(s):
      IVVRFDSOLE

  * 100 random operations (0.4, 0.4, 0.1, 0.1)
    - loitering detected after operation 8 of 100
    - sequence of operations was:
         deque.addLast("QKZFGTBKKG")
         deque.removeFirst()     ==> QKZFGTBKKG
         deque.addFirst("MZGYHZKSBP")
         deque.addFirst("GBUYZVJGJH")
         deque.addFirst("CFOESRYUVF")
         deque.addFirst("ONTCEZBCDJ")
         deque.addFirst("DQBGMBDOOR")
         deque.removeLast()      ==> MZGYHZKSBP
    - loitered object(s):
      MZGYHZKSBP

  * 100 random operations (0.2, 0.2, 0.3, 0.3)
    - loitering detected after operation 3 of 100
    - sequence of operations was:
         deque.addLast("AABKDGLDEX")
         deque.addLast("OENRTJINXM")
         deque.removeLast()      ==> OENRTJINXM
    - loitered object(s):
      OENRTJINXM

==> FAILED

Test 7: worst-case constant memory allocated or de-allocated
        per deque operation?
  * 128 random operations
    - failed on trial 31 of 128
    - when current size of Deque was 6 objects;
    - the call to addLast() caused a change in memory of -144 bytes
    - any change of more than 96 bytes fails the test

  * 256 random operations
  * 512 random operations
    - failed on trial 247 of 512
    - when current size of Deque was 159 objects;
    - the call to addLast() caused a change in memory of -144 bytes
    - any change of more than 96 bytes fails the test

==> FAILED


Min observed memory for Deque: 48.00 n + 40.00   (R^2 = 1.000)
Max observed memory for Deque: 96.00 n - 8.00   (R^2 = 1.000)

Total: 27/48 tests passed!


================================================================


发现 一开始 deque 的memory 只add 可以通过test，但是有了delete 之后，memory会变多
再结合之后loitering 的test
可能是loitering 的问题
确实
如removeFirst 中
Item item = first.item;
first = first.next;
则之前那个node loiters
所以
Node temp = first;
first = first.next;
temp = null
但是会有message temp never accessed again.
想到Node 有 previous element
所以改成
first = first.next
first.previous = null;
removeLast 中做相应改动




Analyzing memory of RandomizedQueue
*-----------------------------------------------------------
For tests 1-5, the maximum amount of memory allowed for
a RandomizedQueue containing n items is 48n + 192.

Test 1a-1i: Total memory usage after inserting n items
            when n is a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
=> passed     4096        32824
=> passed     8192        65592
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 2a-2i: Total memory usage after inserting n items,
            when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33          568
=> passed       65         1080
=> passed      129         2104
=> passed      257         4152
=> passed      513         8248
=> passed     1025        16440
=> passed     2049        32824
=> passed     4097        65592
=> passed     8193       131128
==> 9/9 tests passed

Memory: 16.00 n + 40.00   (R^2 = 1.000)


Test 3a-3i: Total memory usage after inserting 2n-1 items, and then
            deleting n-1 items, when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33         1080
=> passed       65         2104
=> passed      129         4152
=> passed      257         8248
=> passed      513        16440
=> passed     1025        32824
=> passed     2049        65592
=> passed     4097       131128
=> passed     8193       262200
==> 9/9 tests passed

Memory: 32.00 n + 24.00   (R^2 = 1.000)


Test 4a-4i: Total memory usage after inserting n items, deleting n items,
            then inserting n times, when n is a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
=> passed     4096        32824
=> passed     8192        65592
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 5a-5i: Total memory usage after inserting n items,
            and then deleting all but one item.

                 n        bytes
----------------------------------------------------------
=> passed       32           72
=> passed       64           72
=> passed      128           72
=> passed      256           72
=> passed      512           72
=> passed     1024           72
=> passed     2048           72
=> passed     4096           72
=> passed     8192           72
==> 9/9 tests passed

Memory: 72.00   (R^2 = 1.000)


Test 6a-6d: Total memory usage of iterator after inserting n items.

                 n        bytes
----------------------------------------------------------
=> passed       32          192
=> passed       64          320
=> passed      128          576
=> passed      256         1088
=> passed      512         2112
=> passed     1024         4160
=> passed     2048         8256
=> passed     4096        16448
=> passed     8192        32832
==> 9/9 tests passed

Memory: 4.00 n + 64.00   (R^2 = 1.000)


Test 7a: Insert 100 strings; delete them one at a time, checking
         for loitering after each deletion.
==> passed

Test 7b: Perform random operations, checking for loitering after
         each operation. The probabilities of enqueue(), dequeue(),
         and sample() are (p1, p2, p3), respectively.
  * 200 random operations (0.8, 0.2, 0.0)
  * 200 random operations (0.2, 0.8, 0.0)
  * 200 random operations (0.6, 0.2, 0.2)
  * 200 random operations (0.2, 0.4, 0.4)
==> passed

Test 8: Insert T items into queue; then iterate over queue and check
        that worst-case constant memory is allocated or deallocated
        per iterator operation.
  * T = 64
  * T = 128
  * T = 256
==> passed

Test 9: Total memory usage after inserting n items, seeking to identify
        values of n where memory usage is minimized as a function of n.

                 n        bytes
----------------------------------------------------------
=> passed        8          120
=> passed       16          184
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 10: Total memory usage after inserting 4096 items, then successively
         deleting items, seeking values of n where memory usage is maximized
         as a function of n

                 n        bytes
----------------------------------------------------------
=> passed     2049        65592
=> passed     1025        32824
=> passed      513        16440
=> passed      257         8248
=> passed      129         4152
=> passed       65         2104
=> passed       33         1080
=> passed       17          568
=> passed        9          312
==> 9/9 tests passed

Memory: 32.00 n + 24.00   (R^2 = 1.000)


Min observed memory for RandomizedQueue: 8.00 n + 56.00   (R^2 = 1.000)
Max observed memory for RandomizedQueue: 32.00 n + 24.00   (R^2 = 1.000)

Running 75 total tests.

Total: 75/75 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing Deque
*-----------------------------------------------------------
Running 103 total tests.

Test 1a-1k: make n calls to addFirst() followed by n calls to removeFirst()
                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.00
=> passed      512000     0.01
=> passed     1024000     0.03
==> 11/11 tests passed


Test 2a-2k: make n calls to addLast() followed by n calls to removeLast()
                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.00
=> passed      512000     0.01
=> passed     1024000     0.02
==> 11/11 tests passed


Test 3a-3k: make n calls to addFirst() followed by n calls to removeLast()
                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.00
=> passed      512000     0.01
=> passed     1024000     0.02
==> 11/11 tests passed


Test 4a-4k: make n calls to addLast() followed by n calls to removeFirst()
                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.01
=> passed      512000     0.01
=> passed     1024000     0.02
==> 11/11 tests passed


Test 5a-5g: make n random calls to addFirst(), removeFirst(), isEmpty(), and size()
            with probabilities (0.7, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.01
=> passed      512000     0.02
=> passed     1024000     0.04
=> passed     2048000     0.06
==> 12/12 tests passed


Test 6a-6g: make n random calls to addLast(), removeLast(), isEmpty(), and size(),
            with probabilities (0.7, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.01
=> passed      512000     0.02
=> passed     1024000     0.03
=> passed     2048000     0.07
==> 12/12 tests passed


Test 7a-7g: make n random calls to addFirst(), addLast(), removeFirst(), removeLast(),
            isEmpty(), and size() with probabilities (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.01
=> passed      512000     0.02
=> passed     1024000     0.04
=> passed     2048000     0.17
==> 12/12 tests passed


Test 8a-8g: make n calls to addFirst(); iterate over the n items by calling
            next() and hasNext()

                    n  seconds
------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.01
=> passed      512000     0.01
=> passed     1024000     0.02
=> passed     2048000     0.03
==> 12/12 tests passed


Test 9a-9k: make n calls to addFirst()/addLast(); interleave n calls each to
            removeFirst(), removeLast(), addFirst(), and addLast()

                    n  seconds
----------------------------------
=> passed        1025     0.00
=> passed        2049     0.00
=> passed        4097     0.00
=> passed        8193     0.00
=> passed       16385     0.00
=> passed       32769     0.00
=> passed       65537     0.01
=> passed      128001     0.01
=> passed      256001     0.02
=> passed      512001     0.05
=> passed     1024001     0.08
==> 11/11 tests passed

Total: 103/103 tests passed!


================================================================





3*：



********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Permutation
*-----------------------------------------------------------
Running 2 total tests.

Test 1: check that only one Deque or RandomizedQueue object is created
  * filename = distinct.txt, n = 9, k = 1
  * filename = distinct.txt, n = 9, k = 2
  * filename = distinct.txt, n = 9, k = 4
  * filename = tinyTale.txt, n = 12, k = 10
  * filename = tale.txt, n = 138653, k = 50
==> passed

Test 2: check that the maximum size of any Deque or RandomizedQueue object
        created is between k and n
  * filename = distinct.txt, n = 9, k = 1
  * filename = distinct.txt, n = 9, k = 2
  * filename = distinct.txt, n = 9, k = 4
  * filename = tinyTale.txt, n = 12, k = 10
  * filename = tale.txt, n = 138653, k = 5
  * filename = tale.txt, n = 138653, k = 50
  * filename = tale.txt, n = 138653, k = 500
  * filename = tale.txt, n = 138653, k = 5000
  * filename = tale.txt, n = 138653, k = 50000
==> passed

Test 3 (bonus): check that maximum size of any or Deque or RandomizedQueue object
                created is equal to k
  * filename = tale.txt, n = 138653, k = 5
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 50
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 500
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 5000
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 50000
    - max size of RandomizedQueue object = 138653

==> FAILED

Total: 2/2 tests passed!


================================================================


估计是因为有重复的元素，所以会有upper bound (重复item 算作多个item 存储） lower bound
（no duplicated item） 但是如何消除duplicate？


注意，此处test 是permutation.java
所以问题为，在给定n ，k的时候 n 为总的数据量，k 为需要提取的数据量，要满足 k 是
uniform picked among n elements
-> reservoir sampling problem

use the Algorithms R


更改之后：

Test 3 (bonus): check that maximum size of any or Deque or RandomizedQueue object
                created is equal to k
  * filename = tale.txt, n = 138653, k = 5
  * filename = tale.txt, n = 138653, k = 50
  * filename = tale.txt, n = 138653, k = 500
  * filename = tale.txt, n = 138653, k = 5000
  * filename = tale.txt, n = 138653, k = 50000
==> passed

Total: 3/2 tests passed!



4:

Test 7: check removeFirst() and removeLast() from an empty deque
  * removeFirst()
  * removeLast()
==> passed

Test 8: check whether two Deque objects can be created at the same time
  * n = 10
  * n = 1000
==> passed

Test 9: check iterator() after n calls to addFirst()
  * n = 10
  * n = 50
==> passed

Test 10: check iterator() after each of m intermixed calls to
         addFirst(), addLast(), removeFirst(), and removeLast()
  * m = 20
    - number of student   entries = 3
    - number of reference entries = 2
    - iterator() failed after applying operation 10
    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addFirst(1)
         deque.addLast(2)
         deque.removeFirst()   ==> 1
         deque.addFirst(4)
         deque.removeFirst()   ==> 4
         deque.addFirst(6)
         deque.removeFirst()   ==> 6
         deque.addFirst(8)
         deque.addLast(9)
         deque.removeLast()    ==> 9

  * m = 50
    - number of student   entries = 2
    - number of reference entries = 1
    - iterator() failed after applying operation 7
    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addLast(1)
         deque.removeFirst()   ==> 1
         deque.addFirst(3)
         deque.removeFirst()   ==> 3
         deque.addFirst(5)
         deque.addLast(6)
         deque.removeLast()    ==> 6

  * m = 100
    - number of student   entries = 2
    - number of reference entries = 1
    - iterator() failed after applying operation 3
    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addLast(1)
         deque.addFirst(2)
         deque.removeLast()    ==> 1

  * m = 1000
    - number of student   entries = 3
    - number of reference entries = 2
    - iterator() failed after applying operation 4
    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addLast(1)
         deque.addFirst(2)
         deque.addLast(3)
         deque.removeLast()    ==> 3

==> FAILED


可能是deque 之前loitering 导致的
iterator 的问题？









% javac11 Deque.java
*-----------------------------------------------------------



********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Deque
*-----------------------------------------------------------
Running 16 total tests.

Tests 1-6 make random calls to addFirst(), addLast(), removeFirst(),
removeLast(), isEmpty(), and size(). The probabilities of each
operation are (p1, p2, p3, p4, p5, p6), respectively.

Test 1: check random calls to addFirst(), addLast(), and size()
  *    5 random calls (0.4, 0.4, 0.0, 0.0, 0.0, 0.2)
  *   50 random calls (0.4, 0.4, 0.0, 0.0, 0.0, 0.2)
  *  500 random calls (0.4, 0.4, 0.0, 0.0, 0.0, 0.2)
  * 1000 random calls (0.4, 0.4, 0.0, 0.0, 0.0, 0.2)
==> passed

Test 2: check random calls to addFirst(), removeFirst(), and isEmpty()
  *    5 random calls (0.8, 0.0, 0.1, 0.0, 0.1, 0.0)
  *   50 random calls (0.8, 0.0, 0.1, 0.0, 0.1, 0.0)
  *  500 random calls (0.8, 0.0, 0.1, 0.0, 0.1, 0.0)
  * 1000 random calls (0.8, 0.0, 0.1, 0.0, 0.1, 0.0)
  *    5 random calls (0.1, 0.0, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test2(TestDeque.java:459)
    TestDeque.main(TestDeque.java:850)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.isEmpty()         ==> true
         deque.isEmpty()         ==> true
         deque.addFirst(4)
         deque.removeFirst()

  *   50 random calls (0.1, 0.0, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test2(TestDeque.java:460)
    TestDeque.main(TestDeque.java:850)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.addFirst(2)
         deque.removeFirst()

  *  500 random calls (0.1, 0.0, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test2(TestDeque.java:461)
    TestDeque.main(TestDeque.java:850)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeFirst()

  * 1000 random calls (0.1, 0.0, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test2(TestDeque.java:462)
    TestDeque.main(TestDeque.java:850)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.addFirst(2)
         deque.removeFirst()     ==> 2
         deque.removeFirst()

==> FAILED

Test 3: check random calls to addFirst(), removeLast(), and isEmpty()
  *    5 random calls (0.8, 0.0, 0.0, 0.1, 0.1, 0.0)
  *   50 random calls (0.8, 0.0, 0.0, 0.1, 0.1, 0.0)
  *  500 random calls (0.8, 0.0, 0.0, 0.1, 0.1, 0.0)
  * 1000 random calls (0.8, 0.0, 0.0, 0.1, 0.1, 0.0)
  *    5 random calls (0.1, 0.0, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test3(TestDeque.java:475)
    TestDeque.main(TestDeque.java:851)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.addFirst(2)
         deque.removeLast()

  *   50 random calls (0.1, 0.0, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test3(TestDeque.java:476)
    TestDeque.main(TestDeque.java:851)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeLast()

  *  500 random calls (0.1, 0.0, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test3(TestDeque.java:477)
    TestDeque.main(TestDeque.java:851)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeLast()

  * 1000 random calls (0.1, 0.0, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test3(TestDeque.java:478)
    TestDeque.main(TestDeque.java:851)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeLast()

==> FAILED

Test 4: check random calls to addLast(), removeLast(), and isEmpty()
  *    5 random calls (0.0, 0.8, 0.0, 0.1, 0.1, 0.0)
  *   50 random calls (0.0, 0.8, 0.0, 0.1, 0.1, 0.0)
  *  500 random calls (0.0, 0.8, 0.0, 0.1, 0.1, 0.0)
  * 1000 random calls (0.0, 0.8, 0.0, 0.1, 0.1, 0.0)
  *    5 random calls (0.0, 0.1, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test4(TestDeque.java:491)
    TestDeque.main(TestDeque.java:852)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addLast(1)
         deque.removeLast()

  *   50 random calls (0.0, 0.1, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test4(TestDeque.java:492)
    TestDeque.main(TestDeque.java:852)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addLast(1)
         deque.removeLast()

  *  500 random calls (0.0, 0.1, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test4(TestDeque.java:493)
    TestDeque.main(TestDeque.java:852)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addLast(1)
         deque.isEmpty()         ==> false
         deque.removeLast()

  * 1000 random calls (0.0, 0.1, 0.0, 0.8, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test4(TestDeque.java:494)
    TestDeque.main(TestDeque.java:852)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addLast(1)
         deque.removeLast()

==> FAILED

Test 5: check random calls to addLast(), removeFirst(), and isEmpty()
  *    5 random calls (0.0, 0.8, 0.1, 0.0, 0.1, 0.0)
  *   50 random calls (0.0, 0.8, 0.1, 0.0, 0.1, 0.0)
  *  500 random calls (0.0, 0.8, 0.1, 0.0, 0.1, 0.0)
  * 1000 random calls (0.0, 0.8, 0.1, 0.0, 0.1, 0.0)
  *    5 random calls (0.0, 0.1, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test5(TestDeque.java:507)
    TestDeque.main(TestDeque.java:853)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.isEmpty()         ==> true
         deque.addLast(3)
         deque.removeFirst()

  *   50 random calls (0.0, 0.1, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test5(TestDeque.java:508)
    TestDeque.main(TestDeque.java:853)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.addLast(2)
         deque.removeFirst()

  *  500 random calls (0.0, 0.1, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test5(TestDeque.java:509)
    TestDeque.main(TestDeque.java:853)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addLast(1)
         deque.removeFirst()

  * 1000 random calls (0.0, 0.1, 0.8, 0.0, 0.1, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test5(TestDeque.java:510)
    TestDeque.main(TestDeque.java:853)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.isEmpty()         ==> true
         deque.addLast(2)
         deque.addLast(3)
         deque.removeFirst()     ==> 2
         deque.removeFirst()

==> FAILED

Test 6: check random calls to addFirst(), addLast(), removeFirst(),
        removeLast(), isEmpty(), and size()
  *    5 random calls (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)
  *   50 random calls (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)
  *  500 random calls (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)
  * 1000 random calls (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test6(TestDeque.java:524)
    TestDeque.main(TestDeque.java:854)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeFirst()

  *    5 random calls (0.1, 0.1, 0.3, 0.3, 0.1, 0.1)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.random(TestDeque.java:106)
    TestDeque.test6(TestDeque.java:525)
    TestDeque.main(TestDeque.java:854)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.size()            ==> 0
         deque.addLast(2)
         deque.isEmpty()         ==> false
         deque.removeLast()

  *   50 random calls (0.1, 0.1, 0.3, 0.3, 0.1, 0.1)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test6(TestDeque.java:526)
    TestDeque.main(TestDeque.java:854)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.isEmpty()         ==> false
         deque.removeFirst()

  *  500 random calls (0.1, 0.1, 0.3, 0.3, 0.1, 0.1)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test6(TestDeque.java:527)
    TestDeque.main(TestDeque.java:854)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.size()            ==> 0
         deque.addFirst(2)
         deque.removeFirst()

  * 1000 random calls (0.1, 0.1, 0.3, 0.3, 0.1, 0.1)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.random(TestDeque.java:87)
    TestDeque.test6(TestDeque.java:528)
    TestDeque.main(TestDeque.java:854)

    - sequence of operations was:
         Deque<Integer> deque = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeFirst()

==> FAILED

Test 7: check removeFirst() and removeLast() from an empty deque
  * removeFirst()
  * removeLast()
==> passed

Test 8: check whether two Deque objects can be created at the same time
  * n = 10

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.checkTwoDequeObjects(TestDeque.java:192)
    TestDeque.test8(TestDeque.java:590)
    TestDeque.main(TestDeque.java:856)

  * n = 1000

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.checkTwoDequeObjects(TestDeque.java:192)
    TestDeque.test8(TestDeque.java:591)
    TestDeque.main(TestDeque.java:856)

==> FAILED

Test 9: check iterator() after n calls to addFirst()
  * n = 10
  * n = 50
==> passed

Test 10: check iterator() after each of m intermixed calls to
         addFirst(), addLast(), removeFirst(), and removeLast()
  * m = 20
  * m = 50

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.checkIteratorAfterIntermixedOperations(TestDeque.java:260)
    TestDeque.test10(TestDeque.java:628)
    TestDeque.main(TestDeque.java:858)


  * m = 100

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.checkIteratorAfterIntermixedOperations(TestDeque.java:244)
    TestDeque.test10(TestDeque.java:629)
    TestDeque.main(TestDeque.java:858)

    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addLast(1)
         deque.removeFirst()

  * m = 1000

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TestDeque.checkIteratorAfterIntermixedOperations(TestDeque.java:260)
    TestDeque.test10(TestDeque.java:630)
    TestDeque.main(TestDeque.java:858)

    - sequence of operations was:
         Deque deque<Integer> = new Deque<Integer>()
         deque.addFirst(1)
         deque.removeLast()

==> FAILED

Test 11: create two nested iterators to same deque
  * n = 10
  * n = 50
==> passed

Test 12: create two parallel iterators to same deque
==> passed

Test 13: create Deque objects of different parameterized types

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TestDeque.test13(TestDeque.java:661)
    TestDeque.main(TestDeque.java:861)

==> FAILED

Test 14: call addFirst() and addLast() with null argument
==> passed

Test 15: check that remove() and next() throw the specified exceptions in iterator()
==> passed

Test 16: call iterator() when the deque is empty
==> passed


Total: 8/16 tests passed!








自己test 的时候
{8}
再removeFirst 会有 java.lang.NullPointerException
因为之前eliminate loitering 的时候
有
first.previous = null;
若first 已经为null
则没有first.previous 一说。
所以改成

        Item item = first.item;
        // eliminate loitering
        first = first.next;
        numberOfNodes--;
        if (isEmpty()) {
            last = null;
        }
        else {
           first.previous = null;
        }

即test 是否 first 为null


================================================================
Testing correctness of RandomizedQueue
*-----------------------------------------------------------
Running 18 total tests.

Tests 1-4 make random calls to enqueue(), dequeue(), sample(),
isEmpty(), and size(). The probabilities of each operation are
(p1, p2, p3, p4, p5), respectively.

Test 1: check random calls to enqueue() and size()
  *    5 random calls (0.8, 0.0, 0.0, 0.0, 0.2)
  *   50 random calls (0.8, 0.0, 0.0, 0.0, 0.2)
  *  500 random calls (0.8, 0.0, 0.0, 0.0, 0.2)
  * 1000 random calls (0.8, 0.0, 0.0, 0.0, 0.2)
==> passed

Test 2: check random calls to enqueue() and dequeue()
  *    5 random calls (0.7, 0.1, 0.0, 0.1, 0.1)
  *   50 random calls (0.7, 0.1, 0.0, 0.1, 0.1)
  *  500 random calls (0.7, 0.1, 0.0, 0.1, 0.1)
  * 1000 random calls (0.7, 0.1, 0.0, 0.1, 0.1)
  *    5 random calls (0.1, 0.7, 0.0, 0.1, 0.1)
  *   50 random calls (0.1, 0.7, 0.0, 0.1, 0.1)
  *  500 random calls (0.1, 0.7, 0.0, 0.1, 0.1)
  * 1000 random calls (0.1, 0.7, 0.0, 0.1, 0.1)
==> passed

Test 3: check random calls to enqueue(), sample(), and size()
  *    5 random calls (0.8, 0.0, 0.1, 0.0, 0.1)
  *   50 random calls (0.8, 0.0, 0.1, 0.0, 0.1)
  *  500 random calls (0.8, 0.0, 0.1, 0.0, 0.1)
  * 1000 random calls (0.8, 0.0, 0.1, 0.0, 0.1)
  *    5 random calls (0.1, 0.0, 0.8, 0.0, 0.1)
  *   50 random calls (0.1, 0.0, 0.8, 0.0, 0.1)
  *  500 random calls (0.1, 0.0, 0.8, 0.0, 0.1)
  * 1000 random calls (0.1, 0.0, 0.8, 0.0, 0.1)
==> passed

Test 4: check random calls to enqueue(), dequeue(), sample(), isEmpty(), and size()
  *    5 random calls (0.6, 0.1, 0.1, 0.1, 0.1)
  *   50 random calls (0.6, 0.1, 0.1, 0.1, 0.1)
  *  500 random calls (0.6, 0.1, 0.1, 0.1, 0.1)
  * 1000 random calls (0.6, 0.1, 0.1, 0.1, 0.1)
  *    5 random calls (0.1, 0.6, 0.1, 0.1, 0.1)
  *   50 random calls (0.1, 0.6, 0.1, 0.1, 0.1)
  *  500 random calls (0.1, 0.6, 0.1, 0.1, 0.1)
  * 1000 random calls (0.1, 0.6, 0.1, 0.1, 0.1)
==> passed

Test 5: call dequeue() and sample() from an empty randomized queue
  * dequeue()
  * sample()
==> passed

Test 6: create multiple randomized queue objects at the same time
  * n = 10
  * n = 100
==> passed

Test 7: check that iterator() returns correct items after a sequence
        of n enqueue() operations
  * n = 10
  * n = 50
==> passed

Test 8: check that iterator() returns correct items after sequence
        of m enqueue() and dequeue() operations
  * m = 10
  * m = 1000
==> passed

Test 9: create two nested iterators over the same randomized queue
  * n = 10
  * n = 50
==> passed

Test 10: create two parallel iterators over the same randomized queue
  * n = 10
  * n = 50
==> passed

Test 11: create two iterators over different randomized queues
==> passed

Test 12: create RandomizedQueue objects of different parameterized types
==> passed

Test 13: check randomness of sample() by enqueueing n items, repeatedly calling
         sample(), and counting the frequency of each item
  * n = 3, trials = 12000
  * n = 5, trials = 12000
  * n = 8, trials = 12000
  * n = 10, trials = 12000
==> passed

Test 14: check randomness of dequeue() by enqueueing n items, dequeueing n items,
         and seeing whether each of the n! permutations is equally likely
  * n = 2, trials = 12000
  * n = 3, trials = 12000
  * n = 4, trials = 12000
  * n = 5, trials = 12000
==> passed

Test 15: check randomness of iterator() by enqueueing n items, iterating over those
         n items, and seeing whether each of the n! permutations is equally likely
  * n = 2, trials = 12000
  * n = 3, trials = 12000
  * n = 4, trials = 12000
  * n = 5, trials = 12000
==> passed

Test 16: call enqueue() with a null argument
==> passed

Test 17: check that remove() and next() throw the specified exceptions in iterator()
==> passed

Test 18: call iterator() when randomized queue is empty
==> passed


Total: 18/18 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference RandomizedQueue and Deque)
********************************************************************************

Testing correctness of Permutation
*-----------------------------------------------------------
Tests 1-5 call the main() function directly, resetting standard input
before each call.

Running 9 total tests.

Test 1a: check formatting for sample inputs from assignment specification
  % java Permutation 3 < distinct.txt
  A
  G
  D

  % java Permutation 3 < distinct.txt
  G
  E
  B

  % java Permutation 8 < duplicates.txt
  CC
  BB
  CC
  AA
  BB
  BB
  BB
  BB

==> passed

Test 1b: check formatting for other inputs
  % java Permutation 8 < mediumTale.txt
  was
  foolishness
  was
  age
  it
  it
  the
  of

  % java Permutation 0 < distinct.txt
  [no output]

==> passed

Test 2: check that main() reads all data from standard input
  * filename = distinct.txt, k = 3
  * filename = distinct.txt, k = 3
  * filename = duplicates.txt, k = 8
  * filename = mediumTale.txt, k = 8
==> passed

Test 3a: check that main() prints each item from the sequence at most once
         (for inputs with no duplicate strings)
  * filename = distinct.txt, k = 3
  * filename = distinct.txt, k = 1
  * filename = distinct.txt, k = 9
  * filename = permutation6.txt, k = 6
  * filename = permutation10.txt, k = 10
==> passed

Test 3b: check that main() prints each item from the sequence at most once
         (for inputs with duplicate strings)
  * filename = duplicates.txt, k = 8
  * filename = duplicates.txt, k = 3
  * filename = permutation8.txt, k = 6
  * filename = permutation8.txt, k = 2
  * filename = tinyTale.txt, k = 10
==> passed

Test 3c: check that main() prints each item from the sequence at most once
         (for inputs with newlines)
  * filename = mediumTale.txt, k = 10
  * filename = mediumTale.txt, k = 20
  * filename = tale.txt, k = 10
  * filename = tale.txt, k = 50
==> passed

Test 4: check main() when k = 0
  * filename = distinct.txt, k = 0
  * filename = distinct.txt, k = 0
==> passed

Test 5a: check that permutations are uniformly random
         (for inputs with no duplicate strings)
  * filename = permutation4.txt, k = 1
  * filename = permutation4.txt, k = 2
  * filename = permutation4.txt, k = 3
  * filename = permutation4.txt, k = 4
  * filename = permutation6.txt, k = 2
==> passed

Test 5b: check that permutations are uniformly random
         (for inputs with duplicate strings)
  * filename = permutation5.txt, k = 1
  * filename = permutation5.txt, k = 2
  * filename = permutation5.txt, k = 3
  * filename = duplicates.txt, k = 3
  * filename = permutation8.txt, k = 2
==> passed

Total: 9/9 tests passed!


================================================================
********************************************************************************
*  TIMING (substituting reference RandomizedQueue and Deque)
********************************************************************************

Timing Permutation
*-----------------------------------------------------------
Running 23 total tests.

Test 1: count calls to methods in StdIn
  * java Permutation 5 < distinct.txt
  * java Permutation 10 < permutation10.txt
  * java Permutation 1 < mediumTale.txt
  * java Permutation 20 < tale.txt
  * java Permutation 100 < tale.txt
  * java Permutation 16412 < tale.txt
==> passed

Test 2: count calls to methods in Deque and RandomizedQueue
  * java Permutation 5 < distinct.txt
  * java Permutation 10 < permutation10.txt
  * java Permutation 1 < mediumTale.txt
  * java Permutation 20 < tale.txt
  * java Permutation 100 < tale.txt
  * java Permutation 16412 < tale.txt
==> passed

Test 3: count calls to methods in StdRandom
  * java Permutation 5 < distinct.txt
  * java Permutation 10 < permutation10.txt
  * java Permutation 1 < mediumTale.txt
  * java Permutation 20 < tale.txt
  * java Permutation 100 < tale.txt
  * java Permutation 16412 < tale.txt
==> passed

Test 4: Time main() with k = 5, for inputs containing n random strings

                    n  seconds
------------------------------
=> passed        1000     0.00
=> passed        2000     0.00
=> passed        4000     0.00
=> passed        8000     0.00
=> passed       16000     0.01
=> passed       32000     0.01
=> passed       64000     0.03
=> passed      128000     0.05
=> passed      256000     0.11
=> passed      512000     0.45
==> 10/10 tests passed


Test 5: Time main() with k = 1000, for inputs containing n random strings

                    n  seconds
------------------------------
=> passed        1000     0.00
=> passed        2000     0.00
=> passed        4000     0.00
=> passed        8000     0.00
=> passed       16000     0.01
=> passed       32000     0.02
=> passed       64000     0.03
=> passed      128000     0.13
=> passed      256000     0.13
=> passed      512000     0.17
==> 10/10 tests passed


Total: 23/23 tests passed!


================================================================



********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Permutation
*-----------------------------------------------------------
Running 2 total tests.

Test 1: check that only one Deque or RandomizedQueue object is created
  * filename = distinct.txt, n = 9, k = 1
  * filename = distinct.txt, n = 9, k = 2
  * filename = distinct.txt, n = 9, k = 4
  * filename = tinyTale.txt, n = 12, k = 10
  * filename = tale.txt, n = 138653, k = 50
==> passed

Test 2: check that the maximum size of any Deque or RandomizedQueue object
        created is between k and n
  * filename = distinct.txt, n = 9, k = 1
  * filename = distinct.txt, n = 9, k = 2
  * filename = distinct.txt, n = 9, k = 4
  * filename = tinyTale.txt, n = 12, k = 10
  * filename = tale.txt, n = 138653, k = 5
  * filename = tale.txt, n = 138653, k = 50
  * filename = tale.txt, n = 138653, k = 500
  * filename = tale.txt, n = 138653, k = 5000
  * filename = tale.txt, n = 138653, k = 50000
==> passed

Test 3 (bonus): check that maximum size of any or Deque or RandomizedQueue object
                created is equal to k
  * filename = tale.txt, n = 138653, k = 5
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 50
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 500
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 5000
    - max size of RandomizedQueue object = 138653

  * filename = tale.txt, n = 138653, k = 50000
    - max size of RandomizedQueue object = 138653

==> FAILED

Total: 2/2 tests passed!


================================================================



********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Deque
*-----------------------------------------------------------
For tests 1-4, the maximum amount of memory allowed for a Deque
containing n items is 48n + 192.

Running 48 total tests.

Test 1a-1i: total memory usage after inserting n items,
            where n is a power of 2

                 n        bytes
----------------------------------------------------------
=> passed       32         1576
=> passed       64         3112
=> passed      128         6184
=> passed      256        12328
=> passed      512        24616
=> passed     1024        49192
=> passed     2048        98344
=> passed     4096       196648
=> passed     8192       393256
==> 9/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 2a-2i: Total memory usage after inserting n items,
            when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33         1624
=> passed       65         3160
=> passed      129         6232
=> passed      257        12376
=> passed      513        24664
=> passed     1025        49240
=> passed     2049        98392
=> passed     4097       196696
=> passed     8193       393304
==> 9/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 3a-3i: Total memory usage after inserting 2n-1 items, and then
            deleting n-1 items, when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33         1624
=> passed       65         3160
=> passed      129         6232
=> passed      257        12376
=> passed      513        24664
=> passed     1025        49240
=> passed     2049        98392
=> passed     4097       196696
=> passed     8193       393304
==> 9/9 tests passed

Memory: 48.00 n + 40.00   (R^2 = 1.000)


Test 4a-4e: Total memory usage after inserting n items,
            and then deleting all but one item
            (should not grow with n or be too large of a constant).

                 n        bytes
----------------------------------------------------------
=> passed       32           88
=> passed       64           88
=> passed      128           88
=> passed      256           88
=> passed      512           88
=> passed     1024           88
=> passed     2048           88
=> passed     4096           88
=> passed     8192           88
==> 9/9 tests passed

Memory: 88.00   (R^2 = 1.000)


Test 5a-5e: Total memory usage of iterator after inserting n items
            (should not grow with n or be too large of a constant).

                 n        bytes
----------------------------------------------------------
=> passed       32           32
=> passed       64           32
=> passed      128           32
=> passed      256           32
=> passed      512           32
=> passed     1024           32
=> passed     2048           32
=> passed     4096           32
=> passed     8192           32
==> 9/9 tests passed

Memory: 32.00   (R^2 = 1.000)


Test 6a: Insert n strings; delete them one at a time, checking for
         loitering after each deletion. The probabilities of addFirst()
         and addLast() are (p1, p2), respectively. The probabilities of
         removeFirst() and removeLast() are (q1, q2), respectively.
  * 100 random insertions (1.0, 0.0) and 100 random deletions (1.0, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    MemoryOfDeque.loiterInsertionsBeforeDeletions(MemoryOfDeque.java:371)
    MemoryOfDeque.test6a(MemoryOfDeque.java:422)
    MemoryOfDeque.main(MemoryOfDeque.java:655)

  * 100 random insertions (1.0, 0.0) and 100 random deletions (0.0, 1.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    MemoryOfDeque.loiterInsertionsBeforeDeletions(MemoryOfDeque.java:372)
    MemoryOfDeque.test6a(MemoryOfDeque.java:423)
    MemoryOfDeque.main(MemoryOfDeque.java:655)

  * 100 random insertions (0.0, 1.0) and 100 random deletions (1.0, 0.0)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    MemoryOfDeque.loiterInsertionsBeforeDeletions(MemoryOfDeque.java:371)
    MemoryOfDeque.test6a(MemoryOfDeque.java:424)
    MemoryOfDeque.main(MemoryOfDeque.java:655)

  * 100 random insertions (0.0, 1.0) and 100 random deletions (0.0, 1.0)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    MemoryOfDeque.loiterInsertionsBeforeDeletions(MemoryOfDeque.java:372)
    MemoryOfDeque.test6a(MemoryOfDeque.java:425)
    MemoryOfDeque.main(MemoryOfDeque.java:655)

  * 100 random insertions (0.5, 0.5) and 100 random deletions (0.5, 0.5)

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    MemoryOfDeque.loiterInsertionsBeforeDeletions(MemoryOfDeque.java:371)
    MemoryOfDeque.test6a(MemoryOfDeque.java:426)
    MemoryOfDeque.main(MemoryOfDeque.java:655)

==> FAILED

Test 6b: Perform random operations, checking for loitering after
         each operation. The probabilities of addFirst(), addLast(),
         removeFirst(), and removeLast() are (p1, p2, p3, p4),
         respectively.
  * 100 random operations (0.8, 0.0, 0.2, 0.0)
  * 100 random operations (0.8, 0.0, 0.0, 0.2)
  * 100 random operations (0.0, 0.8, 0.2, 0.0)
  * 100 random operations (0.0, 0.8, 0.0, 0.2)
  * 100 random operations (0.4, 0.4, 0.1, 0.1)
  * 100 random operations (0.2, 0.2, 0.3, 0.3)

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    MemoryOfDeque.loiter(MemoryOfDeque.java:481)
    MemoryOfDeque.test6b(MemoryOfDeque.java:544)
    MemoryOfDeque.main(MemoryOfDeque.java:656)

    - sequence of operations was:
         deque.addLast("ZSLBQZDBZQ")
         deque.addFirst("GPKKVJTCCI")
         deque.removeFirst()     ==> GPKKVJTCCI
         deque.removeLast()

==> FAILED

Test 7: worst-case constant memory allocated or de-allocated
        per deque operation?
  * 128 random operations
  * 256 random operations
  * 512 random operations
==> passed


Min observed memory for Deque: 48.00 n + 40.00   (R^2 = 1.000)
Max observed memory for Deque: 48.00 n + 40.00   (R^2 = 1.000)

Total: 46/48 tests passed!


================================================================



Analyzing memory of RandomizedQueue
*-----------------------------------------------------------
For tests 1-5, the maximum amount of memory allowed for
a RandomizedQueue containing n items is 48n + 192.

Test 1a-1i: Total memory usage after inserting n items
            when n is a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
=> passed     4096        32824
=> passed     8192        65592
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 2a-2i: Total memory usage after inserting n items,
            when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33          568
=> passed       65         1080
=> passed      129         2104
=> passed      257         4152
=> passed      513         8248
=> passed     1025        16440
=> passed     2049        32824
=> passed     4097        65592
=> passed     8193       131128
==> 9/9 tests passed

Memory: 16.00 n + 40.00   (R^2 = 1.000)


Test 3a-3i: Total memory usage after inserting 2n-1 items, and then
            deleting n-1 items, when n is one more than a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       33         1080
=> passed       65         2104
=> passed      129         4152
=> passed      257         8248
=> passed      513        16440
=> passed     1025        32824
=> passed     2049        65592
=> passed     4097       131128
=> passed     8193       262200
==> 9/9 tests passed

Memory: 32.00 n + 24.00   (R^2 = 1.000)


Test 4a-4i: Total memory usage after inserting n items, deleting n items,
            then inserting n times, when n is a power of 2.

                 n        bytes
----------------------------------------------------------
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
=> passed     4096        32824
=> passed     8192        65592
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 5a-5i: Total memory usage after inserting n items,
            and then deleting all but one item.

                 n        bytes
----------------------------------------------------------
=> passed       32           72
=> passed       64           72
=> passed      128           72
=> passed      256           72
=> passed      512           72
=> passed     1024           72
=> passed     2048           72
=> passed     4096           72
=> passed     8192           72
==> 9/9 tests passed

Memory: 72.00   (R^2 = 1.000)


Test 6a-6d: Total memory usage of iterator after inserting n items.

                 n        bytes
----------------------------------------------------------
=> passed       32          192
=> passed       64          320
=> passed      128          576
=> passed      256         1088
=> passed      512         2112
=> passed     1024         4160
=> passed     2048         8256
=> passed     4096        16448
=> passed     8192        32832
==> 9/9 tests passed

Memory: 4.00 n + 64.00   (R^2 = 1.000)


Test 7a: Insert 100 strings; delete them one at a time, checking
         for loitering after each deletion.
==> passed

Test 7b: Perform random operations, checking for loitering after
         each operation. The probabilities of enqueue(), dequeue(),
         and sample() are (p1, p2, p3), respectively.
  * 200 random operations (0.8, 0.2, 0.0)
  * 200 random operations (0.2, 0.8, 0.0)
  * 200 random operations (0.6, 0.2, 0.2)
  * 200 random operations (0.2, 0.4, 0.4)
==> passed

Test 8: Insert T items into queue; then iterate over queue and check
        that worst-case constant memory is allocated or deallocated
        per iterator operation.
  * T = 64
  * T = 128
  * T = 256
==> passed

Test 9: Total memory usage after inserting n items, seeking to identify
        values of n where memory usage is minimized as a function of n.

                 n        bytes
----------------------------------------------------------
=> passed        8          120
=> passed       16          184
=> passed       32          312
=> passed       64          568
=> passed      128         1080
=> passed      256         2104
=> passed      512         4152
=> passed     1024         8248
=> passed     2048        16440
==> 9/9 tests passed

Memory: 8.00 n + 56.00   (R^2 = 1.000)


Test 10: Total memory usage after inserting 4096 items, then successively
         deleting items, seeking values of n where memory usage is maximized
         as a function of n

                 n        bytes
----------------------------------------------------------
=> passed     2049        65592
=> passed     1025        32824
=> passed      513        16440
=> passed      257         8248
=> passed      129         4152
=> passed       65         2104
=> passed       33         1080
=> passed       17          568
=> passed        9          312
==> 9/9 tests passed

Memory: 32.00 n + 24.00   (R^2 = 1.000)


Min observed memory for RandomizedQueue: 8.00 n + 56.00   (R^2 = 1.000)
Max observed memory for RandomizedQueue: 32.00 n + 24.00   (R^2 = 1.000)

Running 75 total tests.

Total: 75/75 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing Deque
*-----------------------------------------------------------
Running 103 total tests.

Test 1a-1k: make n calls to addFirst() followed by n calls to removeFirst()
                    n  seconds
----------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeAddRemove(TimeDeque.java:25)
    TimeDeque.timeAddRemove(TimeDeque.java:46)
    TimeDeque.test1(TimeDeque.java:220)
    TimeDeque.main(TimeDeque.java:366)

=> FAILED        1024   [ Test did not complete due to an exception. ]

==> 0/11 tests passed


Test 2a-2k: make n calls to addLast() followed by n calls to removeLast()
                    n  seconds
----------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeAddRemove(TimeDeque.java:25)
    TimeDeque.timeAddRemove(TimeDeque.java:46)
    TimeDeque.test2(TimeDeque.java:226)
    TimeDeque.main(TimeDeque.java:369)

=> FAILED        1024   [ Test did not complete due to an exception. ]

==> 0/11 tests passed


Test 3a-3k: make n calls to addFirst() followed by n calls to removeLast()
                    n  seconds
----------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeAddRemove(TimeDeque.java:25)
    TimeDeque.timeAddRemove(TimeDeque.java:46)
    TimeDeque.test3(TimeDeque.java:232)
    TimeDeque.main(TimeDeque.java:372)

=> FAILED        1024   [ Test did not complete due to an exception. ]

==> 0/11 tests passed


Test 4a-4k: make n calls to addLast() followed by n calls to removeFirst()
                    n  seconds
----------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeAddRemove(TimeDeque.java:25)
    TimeDeque.timeAddRemove(TimeDeque.java:46)
    TimeDeque.test4(TimeDeque.java:238)
    TimeDeque.main(TimeDeque.java:375)

=> FAILED        1024   [ Test did not complete due to an exception. ]

==> 0/11 tests passed


Test 5a-5g: make n random calls to addFirst(), removeFirst(), isEmpty(), and size()
            with probabilities (0.7, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeRandomOperations(TimeDeque.java:98)
    TimeDeque.timeRandomOperations(TimeDeque.java:191)
    TimeDeque.test5(TimeDeque.java:251)
    TimeDeque.main(TimeDeque.java:378)

=> FAILED        1024   Test did not complete due to an exception.

==> 0/12 tests passed


Test 6a-6g: make n random calls to addLast(), removeLast(), isEmpty(), and size(),
            with probabilities (0.7, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------

    java.lang.NullPointerException

    Deque.removeLast(Deque.java:105)
    TimeDeque.timeRandomOperations(TimeDeque.java:107)
    TimeDeque.timeRandomOperations(TimeDeque.java:191)
    TimeDeque.test6(TimeDeque.java:264)
    TimeDeque.main(TimeDeque.java:381)

=> FAILED        1024   Test did not complete due to an exception.

==> 0/12 tests passed


Test 7a-7g: make n random calls to addFirst(), addLast(), removeFirst(), removeLast(),
            isEmpty(), and size() with probabilities (0.3, 0.3, 0.1, 0.1, 0.1, 0.1)

                    n  seconds
------------------------------

    java.lang.NullPointerException

    Deque.removeFirst(Deque.java:89)
    TimeDeque.timeRandomOperations(TimeDeque.java:98)
    TimeDeque.timeRandomOperations(TimeDeque.java:192)
    TimeDeque.test7(TimeDeque.java:277)
    TimeDeque.main(TimeDeque.java:384)

=> FAILED        1024   Test did not complete due to an exception.

==> 0/12 tests passed


Test 8a-8g: make n calls to addFirst(); iterate over the n items by calling
            next() and hasNext()

                    n  seconds
------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.00
=> passed      256000     0.00
=> passed      512000     0.01
=> passed     1024000     0.02
=> passed     2048000     0.04
==> 12/12 tests passed


Test 9a-9k: make n calls to addFirst()/addLast(); interleave n calls each to
            removeFirst(), removeLast(), addFirst(), and addLast()

                    n  seconds
----------------------------------
=> passed        1025     0.00
=> passed        2049     0.00
=> passed        4097     0.00
=> passed        8193     0.00
=> passed       16385     0.00
=> passed       32769     0.00
=> passed       65537     0.01
=> passed      128001     0.01
=> passed      256001     0.02
=> passed      512001     0.04
=> passed     1024001     0.09
==> 11/11 tests passed

Total: 23/103 tests passed!


================================================================



Timing RandomizedQueue
*-----------------------------------------------------------
Running 67 total tests.

Test 1: make n calls to enqueue() followed by n calls to dequeue();
        count calls to StdRandom
  * n = 10
  * n = 100
  * n = 1000
==> passed

Test 2: make n calls to enqueue() follwed by n calls to sample();
        count calls to StdRandom
  * n = 10
  * n = 100
  * n = 1000
==> passed

Test 3: make n calls to enqueue() and iterate over the n items;
        count calls to StdRandom
  * n = 10
  * n = 100
  * n = 1000
==> passed

Test 4a-k: make n calls to enqueue() followed by n calls to dequeue()

                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.01
=> passed      512000     0.03
=> passed     1024000     0.09
==> 11/11 tests passed


Test 5a-k: make n calls to enqueue() followed by n random calls to
           enqueue(), sample(), dequeue(), isEmpty(), and size()
           with probabilities (0.2, 0.2, 0.2, 0.2, 0.2)

                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.01
=> passed      128000     0.01
=> passed      256000     0.02
=> passed      512000     0.05
=> passed     1024000     0.11
==> 11/11 tests passed


Test 6a-k: make n calls to enqueue() followed by n random calls to
           enqueue(), sample(), dequeue(), isEmpty(), and size()
           with probabilities (0.6, 0.1, 0.1, 0.1, 0.1)

                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.02
=> passed      512000     0.04
=> passed     1024000     0.09
==> 11/11 tests passed


Test 7a-k: make n calls to enqueue() followed by n random calls to
           enqueue(), sample(), dequeue(), isEmpty(), and size()
           with probabilities (0.1, 0.1, 0.6, 0.1, 0.1)

                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.02
=> passed      512000     0.05
=> passed     1024000     0.12
==> 11/11 tests passed


Test 8a-k: make n calls to enqueue() followed by n calls each to
           next() and hasNext().

                    n  seconds
----------------------------------
=> passed        1024     0.00
=> passed        2048     0.00
=> passed        4096     0.00
=> passed        8192     0.00
=> passed       16384     0.00
=> passed       32768     0.00
=> passed       65536     0.00
=> passed      128000     0.01
=> passed      256000     0.01
=> passed      512000     0.03
=> passed     1024000     0.06
==> 11/11 tests passed


Test 9a-i: make n calls to enqueue(); then call dequeue() twice,
           followed by enqueue() twice and repeat n times.

                    n  seconds
----------------------------------
=> passed        1025     0.00
=> passed        2049     0.00
=> passed        4097     0.00
=> passed        8193     0.00
=> passed       16385     0.00
=> passed       32769     0.01
=> passed       65537     0.01
=> passed      128001     0.02
=> passed      256001     0.05
==> 9/9 tests passed


Total: 67/67 tests passed!


================================================================




但是可以看到在 3 中问题的地方 此次test pass 说明之前确实是loitering的问题。
现在所有code 改好后，test ok






5. Interview questions


1.Question 1
Intersection of two sets. Given two arrays 𝚊[] and 𝚋[], each containing nn distinct 2D points in the plane, design a subquadratic algorithm to count the number of points that are contained both in array 𝚊[] and array 𝚋[].

Note: these interview questions are ungraded and purely for your own enrichment. To get a hint, submit a solution.


Solution:
sort the two arrays.
Then goes through every element of array a, while comparing that
to the element of b (index from low to high) if one element of array a is also in b
then push it into a queue. we continue with the next element of a and compare it with
the current element of b

The time it costs is bounded by sorting so O(nlogn)





2.Question 2
Permutation. Given two integer arrays of size nn, design a subquadratic algorithm to determine whether one is a permutation of the other. That is, do they contain exactly the same entries but, possibly, in a different order.

Solution:


sort the two integer arrays and compare whether the two sorted arrays have the same element 
at the same index. if yes, then one is a permutation of the other. if not, then it's not.



3.Question 3
Dutch national flag. Given an array of nn buckets, each containing a red, white, or blue pebble, sort them by color. The allowed operations are:

swap(i, j)swap(i,j): swap the pebble in bucket ii with the pebble in bucket jj.
color(i)color(i): determine the color of the pebble in bucket ii.
The performance requirements are as follows:

At most nn calls to color()color().
At most nn calls to swap()swap().
Constant extra space.


Solution:

Suppose want the color to be red white blue. 
maintain three variables, whitePos, redPos,bluePos, where redPos denotes the position, of actual the rightmost red pebble, the bluePos the left most blue pebble, and the whitePos the leftmost white pebble
index begins at 1


int redPos, whitePos, bluePos;
for (int i = 1, j = n; i <= j; i++, j--) {
if (color(i) == red) {
redPos = i;
if (whitePos != 0 && i > whitePos) {
swap(i, whitePos);
// r r r w w w r ..... b b b
// so whitePos = 4, i = 7
// now swap 4,7
// r r r r w w w ... b b b
// whitePos = 5
whitePos++;
}
}
if (color(i) == white) {
// whitePos not set yet
if (whitePos == 0) {
whitePos = i;
}
}
if (color(i) == blue) {
if (bluePos == 0) {
swap(i, j);
bluePos = j;
// minus i so that next round still consider the swapped to the front element
i--;
}
else {
swap(i, --bluePos);
i--;
}
}
}